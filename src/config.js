
// Load path, a builtin library for manipulating file paths.
const path = require('path');

// Define config, a simple object that contains configuration values
// that will be use throughout the application.
const config = {

  // The root directory of this project. Note that this will be some path
  // inside the Docker container.
  ROOT_DIR: __dirname,

  // The port this app will listen on.
  URL_PORT: 10001,
  // TODO: As I write this, I'm realzing that
  // we should distinguish between the prot the app listens on inside the
  // container and the port that a client uses to accesss this app from
  // outside the container. The external port is exposed to clients and
  // is used in URLs when sending requests. Currently the internal and
  // external port are the same. Separating them would allow the server
  // to listen on the same port every time. When deployed, the external
  // port is passed to the server through an environment variable, and
  // would be used when constructing URLs that are sent to the client.
  // I'm not sure if we can separate the two and continue to use the
  // third party libraries that we use. I'll need to investigate that.

  // The external "path" to reach this server.
  URL_PATH: 'http://localhost',
  // TODO: "path" is missused here. It's the term used by
  // the tool that generated this file. But maybe we should fix this.

  // The base version (e.g., v1). It will be appended to the path and port
  // to construct the url that all API endpoints will be based on.
  BASE_VERSION: '',
  // TODO: Why is this the "BASE_VERSION" instead of "URL_VERSION"?
  // Seems inconsistent with other related names.

  // This is where the controllers live within the app. This is used
  // during routing (by express-openapi-validator?).
  CONTROLLER_DIRECTORY: path.join(__dirname, 'controllers'),

  // Location of the root of the project.
  PROJECT_DIR: __dirname,
  // TODO: ROOD_DIR has the same value. Are ROOT_DIR and PROJECT_DIR
  // semantically different? When would there values be different? If
  // never, maybe they are semantically equivallent, and we should remove
  // one of them.
};

// Location of the openapi.yaml file that is generated by openapi-generator-cli.
config.OPENAPI_YAML = path.join(config.ROOT_DIR, 'api', 'openapi.yaml');

// This is the full "path" to the service.
config.FULL_PATH = `${config.URL_PATH}:${config.URL_PORT}/${config.BASE_VERSION}`;
// TODO: "PATH" is missused. This is a URL for accessing the service from outside.
// So FULL_EXTERNAL_URL or FULL_HOST_URL?

// The path to the location where files are uploaded.
config.FILE_UPLOAD_PATH = path.join(config.PROJECT_DIR, 'uploaded_files');
// TODO: Here we see the use of PROJECT_DIR (as opposed to ROOT_DIR).
// So far we don't upload files. But if we do later, then we're going to need it.
// Delete or not?


// CUSTOMIZATIONS =======================================================
// config.js is generated by openapi-generator-cli.
// This section is a customization to what was generated.
//
// TODO: Should this get merged into the above rather than be separate.
// Doing so would mean that we are a hard fork of the generated code.
// I'm starting to beleive that this is the right move.


// Add a SCHEMA config that contains the parsed openapi specification.
// This might be a bit of an abuse of config because config should
// probably have only simple values. However, the openapi specification
// is really part of the configuration of this application. So from
// that perspective, it makes sense.
const jsYaml = require("js-yaml");
const fs = require("fs");
const openapi_yaml_string = fs.readFileSync(config.OPENAPI_YAML);
const openapi_yaml_object = jsYaml.safeLoad(openapi_yaml_string);
config.SCHEMA = openapi_yaml_object;


// Some helpers for constructing the external base URL from config variables.
function ensureStartsWith(string, prefix) {
  if (!string.startsWith(prefix)) {
    return prefix + string;
  }
  return string;
}
function ensureStartsWithIfNotEmpty(string, prefix) {
  if (string !== "") {
    return ensureStartsWith(string, prefix);
  }
  return string;
}

// BASE_VERSION is derived from the API version given in schema, and NOT from
// the URL given in the services section of the specification.
config.BASE_VERSION = ensureStartsWith(config.SCHEMA.info.version.split(".")[0], "v");

// URL_PROTOCOL is either http or https.
config.URL_PROTOCOL = process.env.URL_PROTOCOL;

// URL_SERVER can be a domain name or IP address.
config.URL_SERVER = process.env.URL_SERVER;

// URL_PATH is everthing before the port.
// Note that this is different from the environment variable URL_PATH.
// Then environment variable represents the path component of the URL.
// The config.URL_PATH is the protocol + server part of the URL.
// Since this is the meaning that the generator produceds, we do
// not change its meaning here.
config.URL_PATH = config.URL_PROTOCOL + "://" + config.URL_SERVER;

// URL_PORT the port assigned to the service.
config.URL_PORT = process.env.URL_PORT;

// FULL_PATH
// It really should be called FULL_URL. But this is what the generator
// generates. So we work with it.
const protocol = config.URL_PROTOCOL;
const server = ensureStartsWith(config.URL_SERVER, "://");
const port = ensureStartsWithIfNotEmpty(config.URL_PORT, ":");
const url_path = ensureStartsWithIfNotEmpty(process.env.URL_PATH, "/");
const version = ensureStartsWithIfNotEmpty(config.BASE_VERSION, "/");
config.FULL_PATH = `${protocol}${server}${port}${url_path}${version}`;

// Replace the URL in the SCHEMA with FULL_PATH
// so the interactive documentation works properly.
config.SCHEMA.servers[0].url = config.FULL_PATH;

config.MONGO_URI = process.env.MONGO_URI;
// End of CUSTOMIZATIONS ===============================================

module.exports = config;
